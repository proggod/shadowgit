import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { ShadowGit } from './shadowGit';
import { ShadowGitWithGit } from './shadowGitWithGit';
import { DiffDecorationProvider } from './diffProvider';
import { GitUtils } from './gitUtils';

/**
 * Creates specialized commands for the enhanced Shadow Git system
 */
export function createShadowGitCommands(
  context: vscode.ExtensionContext,
  mainShadowGit: ShadowGit,
  workingShadowGit: ShadowGitWithGit,
  mainDiffDecorationProvider: DiffDecorationProvider,
  workingDiffDecorationProvider: DiffDecorationProvider
): vscode.Disposable[] {
  const commands: vscode.Disposable[] = [];
  
  // Main Shadow Git diff command (with checkpoints focus)
  commands.push(vscode.commands.registerCommand('shadowGit.openMainDiff', async (uri: vscode.Uri) => {
    console.log('shadowGit.openMainDiff command invoked');
    
    if (!mainShadowGit) {
      vscode.window.showErrorMessage('Main Shadow Git not initialized');
      return;
    }
    
    await openDiff(uri, mainShadowGit, mainDiffDecorationProvider, context, 'main');
  }));
  
  // Working Shadow Git diff command (with Git-based staging)
  commands.push(vscode.commands.registerCommand('shadowGit.openWorkingDiff', async (uri: vscode.Uri) => {
    console.log('shadowGit.openWorkingDiff command invoked');
    
    if (!workingShadowGit) {
      vscode.window.showErrorMessage('Working Shadow Git not initialized');
      return;
    }
    
    await openDiff(uri, workingShadowGit, workingDiffDecorationProvider, context, 'working');
  }));
  
  // Set base commit command
  commands.push(vscode.commands.registerCommand('shadowGit.setBaseCommit', async () => {
    if (!workingShadowGit) {
      vscode.window.showErrorMessage('Working Shadow Git not initialized');
      return;
    }
    
    // Get all checkpoints
    const checkpoints = workingShadowGit.getCheckpoints();
    
    if (checkpoints.length === 0) {
      vscode.window.showInformationMessage('No checkpoints available. Create a checkpoint first.');
      return;
    }
    
    // Let user choose which checkpoint to use as base
    const items = checkpoints.map(cp => ({
      label: cp.message,
      description: new Date(cp.timestamp).toLocaleString(),
      detail: `ID: ${cp.id.substring(0, 8)}`,
      id: cp.id
    }));
    
    const choice = await vscode.window.showQuickPick(items, { 
      placeHolder: 'Select checkpoint to use as base reference',
      title: 'Set Base Commit'
    });
    
    if (choice) {
      // Store the base commit ID in workspace state
      context.workspaceState.update('shadowgit.baseCommit', choice.id);
      workingShadowGit.setBaseCommit(choice.id);
      vscode.window.showInformationMessage(`Set checkpoint "${choice.label}" as the new base reference");
    }
  }));
  
  // Stage all changes command
  commands.push(vscode.commands.registerCommand('shadowGit.stageAll', async () => {
    if (!workingShadowGit) {
      vscode.window.showErrorMessage('Working Shadow Git not initialized');
      return;
    }
    
    // Get all tracked files
    const files = workingShadowGit.getTrackedFiles();
    let stageCount = 0;
    
    // Stage changes in each file
    for (const relativePath of files) {
      const fullPath = path.join(workingShadowGit.workspaceRoot, relativePath);
      const count = await workingShadowGit.approveAllChanges(fullPath);
      stageCount += count;
    }
    
    vscode.window.showInformationMessage(`Staged ${stageCount} changes in ${files.length} files");
  }));
  
  // Unstage all changes command
  commands.push(vscode.commands.registerCommand('shadowGit.unstageAll', async () => {
    if (!workingShadowGit) {
      vscode.window.showErrorMessage('Working Shadow Git not initialized');
      return;
    }
    
    // Get all tracked files
    const files = workingShadowGit.getTrackedFiles();
    let unstageCount = 0;
    
    // Unstage changes in each file
    for (const relativePath of files) {
      const fullPath = path.join(workingShadowGit.workspaceRoot, relativePath);
      const count = await workingShadowGit.disapproveAllChanges(fullPath);
      unstageCount += count;
    }
    
    vscode.window.showInformationMessage(`Unstaged ${unstageCount} changes in ${files.length} files");
  }));
  
  return commands;
}

/**
 * Open a diff view for a file using the specified Shadow Git system
 */
async function openDiff(
  uri: vscode.Uri, 
  shadowGit: ShadowGit | ShadowGitWithGit, 
  diffProvider: DiffDecorationProvider,
  context: vscode.ExtensionContext,
  type: 'main' | 'working'
): Promise<void> {
  // Show progress notification
  await vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: `Opening ${type === 'main' ? 'Checkpoint' : 'Comparison'} Diff`,
    cancellable: false
  }, async (progress) => {
    let statusBarItem: vscode.StatusBarItem | null = null;
    
    try {
      progress.report({ message: "Preparing diff view..." });
      
      // Close any active editor
      try {
        await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
        console.log('Closed any active editor');
      } catch (error) {
        console.log("Error closing editor: ${error}");
      }
      
      // Brief delay to let the editor close
      await new Promise(resolve => setTimeout(resolve, 500));
      progress.report({ message: "Creating snapshot..." });
    
      const filePath = uri.fsPath;
      const relativePath = path.relative(shadowGit.workspaceRoot, filePath);
    
      // Take a snapshot if not already taken
      if (!(shadowGit.snapshots.has(relativePath))) {
        if (shadowGit instanceof ShadowGitWithGit) {
          await shadowGit.takeSnapshot(filePath);
        } else {
          shadowGit.takeSnapshot(filePath);
        }
      }
      
      // Detect changes
      let changes: any;
      if (shadowGit instanceof ShadowGitWithGit) {
        changes = await shadowGit.detectChanges(filePath);
      } else {
        changes = shadowGit.detectChanges(filePath);
      }
      
      // Create temp file for the snapshot
      const tempPath = shadowGit.createTempSnapshotFile(relativePath);
      
      // Open the diff editor
      const leftUri = vscode.Uri.file(tempPath);
      const rightUri = uri;
      
      console.log("Opening diff with leftUri: ${leftUri.toString()}, rightUri: ${rightUri.toString()}");
      
      // Check if this is the working shadow git and has Git integration
      let usedGitDiff = false;
      
      if (type === 'working') {
        progress.report({ message: "Opening Git diff view..." });
        
        try {
          // For working mode, try to use Git's diff facility
          const gitRepoDir = (shadowGit as ShadowGitWithGit).gitRepoDir;
          
          if (fs.existsSync(path.join(gitRepoDir, '.git'))) {
            // Try to use VS Code's Git extension
            try {
              // Save the Git repo path to use for staging operations
              context.workspaceState.update('shadowgit.gitRepoDir', gitRepoDir);
              
              // Register the file with the Git extensions
              usedGitDiff = await vscode.commands.executeCommand('git.openChange', rightUri);
              console.log("Git diff command result: ${usedGitDiff ? 'success' : 'failed'}");
            } catch (error) {
              console.log("Error using git diff: ${error}");
              usedGitDiff = false;
            }
          }
        } catch (error) {
          console.log("Failed to use Git diff: ${error}");
          usedGitDiff = false;
        }
      }
      
      // If we couldn't use Git diff, fall back to normal diff
      if (!usedGitDiff) {
        console.log('Falling back to normal diff');
        progress.report({ message: "Opening regular diff view..." });
        
        // Use standard diff command
        await vscode.commands.executeCommand('vscode.diff', 
          leftUri,
          rightUri,
          `Shadow Git ${type === 'main' ? 'Checkpoint' : 'Comparison'} Diff: ${path.basename(filePath)}`
        );
      }
      
      // Let the diff editor fully load
      await new Promise(resolve => setTimeout(resolve, 1000));
      progress.report({ message: "Finalizing diff view..." });
      
      // Create a status bar item for approve/disapprove actions
      const actionText = type === 'main' ? 
        "$(check) Approve All | $(x) Disapprove All" : 
        "$(check) Stage All | $(x) Unstage All";
      
      statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
      statusBarItem.text = actionText;
      statusBarItem.tooltip = `Shadow Git: ${type === 'main' ? 'Approve or Disapprove' : 'Stage or Unstage'} All Changes`;
      statusBarItem.command = type === 'main' ? "shadowGit.showApprovalOptions" : "shadowGit.showStagingOptions";
      statusBarItem.show();
      
      // Register the command for the status bar item
      if (!context.subscriptions.find(d => (d as any)?.command === 'shadowGit.showApprovalOptions') && type === 'main') {
        context.subscriptions.push(vscode.commands.registerCommand('shadowGit.showApprovalOptions', async () => {
          const options = ['Approve All Changes', 'Disapprove All Changes'];
          const choice = await vscode.window.showQuickPick(options, { placeHolder: 'Choose an action' });
          
          if (choice === options[0]) {
            await vscode.commands.executeCommand('shadowGit.approveAllChanges', rightUri);
            vscode.window.showInformationMessage('All changes approved');
          } else if (choice === options[1]) {
            await vscode.commands.executeCommand('shadowGit.disapproveAllChanges', rightUri);
            vscode.window.showInformationMessage('All changes disapproved');
          }
        }));
      }
      
      // Register similar command for working shadow git staging
      if (!context.subscriptions.find(d => (d as any)?.command === 'shadowGit.showStagingOptions') && type === 'working') {
        context.subscriptions.push(vscode.commands.registerCommand('shadowGit.showStagingOptions', async () => {
          const options = ['Stage All Changes', 'Unstage All Changes'];
          const choice = await vscode.window.showQuickPick(options, { placeHolder: 'Choose an action' });
          
          if (choice === options[0]) {
            await shadowGit.approveAllChanges(filePath);
            vscode.window.showInformationMessage('All changes staged');
          } else if (choice === options[1]) {
            await shadowGit.disapproveAllChanges(filePath);
            vscode.window.showInformationMessage('All changes unstaged');
          }
        }));
      }
      
      // Force-apply decorations
      console.log("Registering diff editor for decoration");
      diffProvider.registerDiffEditor(rightUri, changes);
      
      // Register cleanup on editor close
      const disposable = vscode.window.onDidChangeVisibleTextEditors(() => {
        if (!vscode.window.visibleTextEditors.some(e => e.document.uri.toString() === rightUri.toString())) {
          if (statusBarItem) {
            statusBarItem.dispose();
          }
          disposable.dispose();
        }
      });
      
      context.subscriptions.push(disposable);
      
      console.log("Diff view opened successfully");
    } catch (error) {
      console.error(`Failed to open diff: ${(error as Error).message}");
      console.error(`Error stack: ${(error as Error).stack}");
      vscode.window.showErrorMessage(`Failed to open diff: ${(error as Error).message}");
      
      if (statusBarItem) {
        statusBarItem.dispose();
      }
    }
  });
}